package readgo

import (
	"bytes"
	"context"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// DefaultReader implements SourceReader
type DefaultReader struct {
	workDir string
}

// NewSourceReader creates a new DefaultReader instance
func NewSourceReader(workDir string) SourceReader {
	return &DefaultReader{
		workDir: workDir,
	}
}

// ReadSourceFile reads a source file with the given options
func (r *DefaultReader) ReadSourceFile(ctx context.Context, path string, opts ReadOptions) ([]byte, error) {
	if path == "" {
		return nil, fmt.Errorf("empty path")
	}

	// Convert to absolute path if needed
	absPath := path
	if !filepath.IsAbs(path) {
		absPath = filepath.Join(r.workDir, path)
	}

	// Clean the path
	absPath = filepath.Clean(absPath)

	// Verify file exists and get info
	info, err := os.Stat(absPath)
	if err != nil {
		return nil, err
	}

	// Check if it's a regular file
	if !info.Mode().IsRegular() {
		return nil, fmt.Errorf("not a regular file: %s", path)
	}

	// Read file
	content, err := os.ReadFile(absPath)
	if err != nil {
		return nil, err
	}

	// Apply options
	if opts.StripSpaces {
		content = bytes.TrimSpace(content)
	}

	return content, nil
}

// NewDefaultReader creates a new DefaultReader instance
func NewDefaultReader() *DefaultReader {
	return &DefaultReader{}
}

// WithWorkDir sets the working directory for the reader
func (r *DefaultReader) WithWorkDir(dir string) *DefaultReader {
	r.workDir = dir
	return r
}

// ReadFileWithFunctions reads a source file and returns its content along with function positions
func (r *DefaultReader) ReadFileWithFunctions(ctx context.Context, path string) (*FileContent, error) {
	content, err := r.ReadSourceFile(ctx, path, ReadOptions{})
	if err != nil {
		return nil, err
	}

	// Parse the file
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, path, content, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	// Extract function positions
	var functions []FunctionPosition
	for _, decl := range file.Decls {
		if fn, ok := decl.(*ast.FuncDecl); ok {
			pos := fset.Position(fn.Pos())
			end := fset.Position(fn.End())
			functions = append(functions, FunctionPosition{
				Name:      fn.Name.Name,
				StartLine: pos.Line,
				EndLine:   end.Line,
			})
		}
	}

	return &FileContent{
		Content:   content,
		Functions: functions,
	}, nil
}

// isGeneratedFile checks if a file is generated based on its content
func isGeneratedFile(content []byte) bool {
	contentStr := string(content)
	markers := []string{
		"Code generated", "DO NOT EDIT",
		"@generated",
		"// Generated by",
		"/* Generated by",
	}

	for _, marker := range markers {
		if strings.Contains(contentStr, marker) {
			return true
		}
	}
	return false
}

// findNode finds a node in the tree by its path
func findNode(root *FileTreeNode, path string) *FileTreeNode {
	if root.Path == path {
		return root
	}

	for _, child := range root.Children {
		if child.Type == "directory" {
			if node := findNode(child, path); node != nil {
				return node
			}
		}
	}

	return nil
}

// SearchFiles searches for files matching the given pattern
func (r *DefaultReader) SearchFiles(ctx context.Context, pattern string, opts TreeOptions) ([]*FileTreeNode, error) {
	if pattern == "" {
		return nil, ErrInvalidInput
	}

	tree, err := r.GetFileTree(ctx, ".", opts)
	if err != nil {
		return nil, err
	}

	var matches []*FileTreeNode
	var search func(*FileTreeNode)
	search = func(node *FileTreeNode) {
		if node.Type == "file" && strings.Contains(node.Name, pattern) {
			matches = append(matches, node)
		}
		for _, child := range node.Children {
			search(child)
		}
	}
	search(tree)

	return matches, nil
}

// GetPackageFiles returns all files in a package
func (r *DefaultReader) GetPackageFiles(ctx context.Context, pkgPath string, opts TreeOptions) ([]*FileTreeNode, error) {
	tree, err := r.GetFileTree(ctx, pkgPath, opts)
	if err != nil {
		return nil, err
	}

	var files []*FileTreeNode
	var collect func(*FileTreeNode)
	collect = func(node *FileTreeNode) {
		if node.Type == "file" {
			files = append(files, node)
		}
		for _, child := range node.Children {
			collect(child)
		}
	}
	collect(tree)

	return files, nil
}

// GetFileTree returns the file tree starting from the given root
func (r *DefaultReader) GetFileTree(ctx context.Context, root string, opts TreeOptions) (*FileTreeNode, error) {
	if root == "" {
		root = "."
	}

	absRoot := filepath.Join(r.workDir, root)
	absRoot, err := filepath.Abs(absRoot)
	if err != nil {
		return nil, err
	}

	tree := &FileTreeNode{
		Name: filepath.Base(absRoot),
		Path: root,
		Type: "directory",
	}

	err = filepath.Walk(absRoot, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip if path matches exclude patterns
		for _, pattern := range opts.ExcludePatterns {
			if matched, _ := filepath.Match(pattern, info.Name()); matched {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
		}

		// Skip if path doesn't match include patterns
		if len(opts.IncludePatterns) > 0 {
			matched := false
			for _, pattern := range opts.IncludePatterns {
				if m, _ := filepath.Match(pattern, info.Name()); m {
					matched = true
					break
				}
			}
			if !matched {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
		}

		// Convert absolute path to relative path
		relPath, err := filepath.Rel(r.workDir, path)
		if err != nil {
			return err
		}

		node := &FileTreeNode{
			Name:    info.Name(),
			Path:    relPath,
			Size:    info.Size(),
			ModTime: info.ModTime(),
		}

		if info.IsDir() {
			node.Type = "directory"
		} else {
			node.Type = "file"
		}

		// Find parent node
		if path != absRoot {
			parentPath := filepath.Dir(relPath)
			parentNode := findNode(tree, parentPath)
			if parentNode != nil {
				parentNode.Children = append(parentNode.Children, node)
				// Sort children by name
				sort.Slice(parentNode.Children, func(i, j int) bool {
					return parentNode.Children[i].Name < parentNode.Children[j].Name
				})
			}
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return tree, nil
}
